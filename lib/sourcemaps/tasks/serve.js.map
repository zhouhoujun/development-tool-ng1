{"version":3,"sources":["tasks/serve.ts"],"names":["_","require","development_core_1","browserSync","path","StartServer","info","this","prototype","getInfo","name","setup","ctx","gulp","option","browsersync","watchOptions","ignoreInitial","ignored","files","rf","to","isArray","filesByCtx","dfs","concat","push","pkg","getPackage","rootpath","getRootPath","packagePath","jspm","packages","toRootPath","toStr","directories","hascfg","pkgname","basename","pkgreg","RegExp","map","it","isString","test","match","options","relative","dist","getDist","baseDir","toRootSrc","isFunction","dirname","relpkg","first","uniq","dr","isAbsolute","browsersyncOption","extend","open","port","process","env","PORT","omit","server","tkn","subTaskName","task","callback","err","bs","__decorate","order","total","value","runWay","RunWay","parallel","oper","Operation","default","serve","exports"],"mappings":"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","file":"../../tasks/serve.js","sourcesContent":["import * as _ from 'lodash';\nimport * as chalk from 'chalk';\nimport { TaskCallback, Gulp } from 'gulp';\nimport { Src, ITask, ITaskInfo, Operation, task, ITaskContext, RunWay } from 'development-core';\nimport { IWebTaskOption } from '../WebTaskOption';\nimport * as browserSync from 'browser-sync';\nimport * as path from 'path';\n\n@task({\n    order: (total, ctx) => ctx.env.test ? { value: 2 / total, runWay: RunWay.parallel } : 1, // last order.\n    oper: Operation.default | Operation.serve\n})\nexport class StartServer implements ITask {\n    constructor(private info: ITaskInfo) {\n    }\n    getInfo() {\n        this.info.name = this.info.name || 'web-serve';\n        return this.info;\n    }\n    setup(ctx: ITaskContext, gulp: Gulp) {\n        let option = (<IWebTaskOption>ctx.option).browsersync || {};\n        let watchOptions = option.watchOptions || { ignoreInitial: true, ignored: ['*.txt', '*.map', '*.d.ts'] };\n        let files: any[] = [];\n        if (option.files) {\n            let rf = ctx.to(option.files);\n            files = _.isArray(rf) ? rf : [rf];\n        }\n        if (option.filesByCtx) {\n            let dfs = ctx.to(option.filesByCtx);\n            if (_.isArray(dfs)) {\n                files = files.concat(dfs);\n            } else {\n                files.push(dfs);\n            }\n        }\n\n        let pkg = ctx.getPackage();\n        let rootpath = ctx.getRootPath();\n        let packagePath = '';\n        if (option.jspm && option.jspm.packages) {\n            packagePath = ctx.toRootPath(ctx.toStr(option.jspm.packages));\n        } else {\n            if (pkg.jspm && pkg.jspm && pkg.jspm.directories) {\n                packagePath = ctx.toRootPath(pkg.jspm.directories.packages);\n            } else {\n                packagePath = ctx.toRootPath('./node_modules');\n            }\n        }\n\n\n        let hascfg = false;\n        let pkgname = path.basename(packagePath);\n        watchOptions.ignored = _.isArray(watchOptions.ignored) ? watchOptions.ignored : [watchOptions.ignored];\n        watchOptions.ignored.push(pkgname + '/**');\n        let pkgreg = new RegExp('/^' + pkgname + '\\//', 'gi');\n        files = _.map(files || [], it => {\n            if (_.isString(it)) {\n                if (!hascfg) {\n                    hascfg = pkgreg.test(it);\n                }\n                return {\n                    match: it,\n                    options: watchOptions\n                }\n            } else {\n                return it;\n            }\n        });\n\n        if (!hascfg && packagePath) {\n            // files.push(`${path.relative(rootpath, packagePath)}/**`)\n            files.push({\n                match: `${path.relative(rootpath, packagePath)}/**`,\n                options: watchOptions\n            });\n        }\n\n        let dist = ctx.getDist(this.getInfo());\n        let baseDir: Src = null;\n        if (option.baseDir) {\n            baseDir = ctx.toRootSrc(_.isFunction(option.baseDir) ? option.baseDir(ctx) : option.baseDir);\n        } else {\n            baseDir = dist;\n        }\n        baseDir = _.isArray(baseDir) ? baseDir : [baseDir];\n        baseDir.push(path.dirname(packagePath));\n        let relpkg = path.relative(_.first(baseDir), packagePath);\n        if (/^\\.\\./.test(relpkg)) {\n            baseDir.push(rootpath);\n        }\n\n        baseDir = _.uniq(_.map(baseDir, dr => {\n            if (path.isAbsolute(dr)) {\n                return path.relative(rootpath, dr) || '.';\n            } else {\n                return dr;\n            }\n        }));\n\n\n        files.push({\n            match: `${path.relative(rootpath, dist)}/**`,\n            options: watchOptions\n        });\n\n        let browsersyncOption = <browserSync.Options>_.extend(\n            {\n                open: true,\n                port: process.env.PORT || 3000\n            },\n            _.omit(option, ['files', 'baseDir', 'jspm']),\n            {\n                watchOptions: watchOptions,\n                server: {\n                    baseDir: baseDir\n                },\n                files: files\n            });\n\n        let tkn = ctx.subTaskName(this.info);\n        gulp.task(tkn, (callback: TaskCallback) => {\n            browserSync(browsersyncOption, (err, bs) => {\n                if (err) {\n                    callback(<any>err);\n                }\n            });\n        });\n\n        return tkn;\n    }\n}\n"]}