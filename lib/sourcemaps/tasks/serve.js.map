{"version":3,"sources":["tasks/serve.ts"],"names":["_","require","development_core_1","browserSync","path","StartServer","info","this","prototype","getInfo","name","setup","ctx","gulp","option","browsersync","watchOptions","ignoreInitial","ignored","files","rf","to","isArray","filesByCtx","dfs","concat","push","pkg","getPackage","rootpath","getRootPath","packagePath","jspm","packages","toRootPath","toStr","directories","hascfg","pkgname","basename","pkgreg","RegExp","map","it","isString","test","match","options","relative","dist","getDist","baseDir","toRootSrc","isFunction","dirname","relpkg","first","uniq","dr","isAbsolute","browsersyncOption","extend","open","port","process","env","PORT","omit","server","tkn","subTaskName","task","callback","err","bs","__decorate","order","total","value","runWay","RunWay","parallel","oper","Operation","default","serve","exports"],"mappings":"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","file":"../../tasks/serve.js","sourcesContent":["import * as _ from 'lodash';\r\nimport * as chalk from 'chalk';\r\nimport { TaskCallback, Gulp } from 'gulp';\r\nimport { Src, ITask, ITaskInfo, Operation, task, ITaskContext, RunWay } from 'development-core';\r\nimport { IWebTaskOption } from '../WebTaskOption';\r\nimport * as browserSync from 'browser-sync';\r\nimport * as path from 'path';\r\n\r\n@task({\r\n    order: (total, ctx) => ctx.env.test ? { value: 2 / total, runWay: RunWay.parallel } : 1, // last order.\r\n    oper: Operation.default | Operation.serve\r\n})\r\nexport class StartServer implements ITask {\r\n    constructor(private info: ITaskInfo) {\r\n    }\r\n    getInfo() {\r\n        this.info.name = this.info.name || 'web-serve';\r\n        return this.info;\r\n    }\r\n    setup(ctx: ITaskContext, gulp: Gulp) {\r\n        let option = (<IWebTaskOption>ctx.option).browsersync || {};\r\n        let watchOptions = option.watchOptions || { ignoreInitial: true, ignored: ['*.txt', '*.map', '*.d.ts'] };\r\n        let files: any[] = [];\r\n        if (option.files) {\r\n            let rf = ctx.to(option.files);\r\n            files = _.isArray(rf) ? rf : [rf];\r\n        }\r\n        if (option.filesByCtx) {\r\n            let dfs = ctx.to(option.filesByCtx);\r\n            if (_.isArray(dfs)) {\r\n                files = files.concat(dfs);\r\n            } else {\r\n                files.push(dfs);\r\n            }\r\n        }\r\n\r\n        let pkg = ctx.getPackage();\r\n        let rootpath = ctx.getRootPath();\r\n        let packagePath = '';\r\n        if (option.jspm && option.jspm.packages) {\r\n            packagePath = ctx.toRootPath(ctx.toStr(option.jspm.packages));\r\n        } else {\r\n            if (pkg.jspm && pkg.jspm && pkg.jspm.directories) {\r\n                packagePath = ctx.toRootPath(pkg.jspm.directories.packages);\r\n            } else {\r\n                packagePath = ctx.toRootPath('./node_modules');\r\n            }\r\n        }\r\n\r\n\r\n        let hascfg = false;\r\n        let pkgname = path.basename(packagePath);\r\n        watchOptions.ignored = _.isArray(watchOptions.ignored) ? watchOptions.ignored : [watchOptions.ignored];\r\n        watchOptions.ignored.push(pkgname + '/**');\r\n        let pkgreg = new RegExp('/^' + pkgname + '\\//', 'gi');\r\n        files = _.map(files || [], it => {\r\n            if (_.isString(it)) {\r\n                if (!hascfg) {\r\n                    hascfg = pkgreg.test(it);\r\n                }\r\n                return {\r\n                    match: it,\r\n                    options: watchOptions\r\n                }\r\n            } else {\r\n                return it;\r\n            }\r\n        });\r\n\r\n        if (!hascfg && packagePath) {\r\n            // files.push(`${path.relative(rootpath, packagePath)}/**`)\r\n            files.push({\r\n                match: `${path.relative(rootpath, packagePath)}/**`,\r\n                options: watchOptions\r\n            });\r\n        }\r\n\r\n        let dist = ctx.getDist(this.getInfo());\r\n        let baseDir: Src = null;\r\n        if (option.baseDir) {\r\n            baseDir = ctx.toRootSrc(_.isFunction(option.baseDir) ? option.baseDir(ctx) : option.baseDir);\r\n        } else {\r\n            baseDir = dist;\r\n        }\r\n        baseDir = _.isArray(baseDir) ? baseDir : [baseDir];\r\n        baseDir.push(path.dirname(packagePath));\r\n        let relpkg = path.relative(_.first(baseDir), packagePath);\r\n        if (/^\\.\\./.test(relpkg)) {\r\n            baseDir.push(rootpath);\r\n        }\r\n\r\n        baseDir = _.uniq(_.map(baseDir, dr => {\r\n            if (path.isAbsolute(dr)) {\r\n                return path.relative(rootpath, dr) || '.';\r\n            } else {\r\n                return dr;\r\n            }\r\n        }));\r\n\r\n\r\n        files.push({\r\n            match: `${path.relative(rootpath, dist)}/**`,\r\n            options: watchOptions\r\n        });\r\n\r\n        let browsersyncOption = <browserSync.Options>_.extend(\r\n            {\r\n                open: true,\r\n                port: process.env.PORT || 3000\r\n            },\r\n            _.omit(option, ['files', 'baseDir', 'jspm']),\r\n            {\r\n                watchOptions: watchOptions,\r\n                server: {\r\n                    baseDir: baseDir\r\n                },\r\n                files: files\r\n            });\r\n\r\n        let tkn = ctx.subTaskName(this.info);\r\n        gulp.task(tkn, (callback: TaskCallback) => {\r\n            browserSync(browsersyncOption, (err, bs) => {\r\n                if (err) {\r\n                    callback(<any>err);\r\n                }\r\n            });\r\n        });\r\n\r\n        return tkn;\r\n    }\r\n}\r\n"]}